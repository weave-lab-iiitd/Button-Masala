import zbar
import numpy as np
import numpy as np
from matplotlib import pyplot as plt
from matplotlib import animation
from PIL import Image
import cv2
import pyzbar.pyzbar as pyzbar
import numpy as np
import cv2
import imutils
def Zoom(cv2Object, zoomSize):
    # Resizes the image/video frame to the specified amount of "zoomSize".
    # A zoomSize of "2", for example, will double the canvas size
    cv2Object = imutils.resize(cv2Object, width=(zoomSize * cv2Object.shape[1]))
    # center is simply half of the height & width (y/2,x/2)
    center = (cv2Object.shape[0]/2,cv2Object.shape[1]/2)
    # cropScale represents the top left corner of the cropped frame (y/x)
    cropScale = (center[0]/zoomSize, center[1]/zoomSize)
    # The image/video frame is cropped to the center with a size of the original picture
    # image[y1:y2,x1:x2] is used to iterate and grab a portion of an image
    # (y1,x1) is the top left corner and (y2,x1) is the bottom right corner of new cropped frame.
    cv2Object = cv2Object[cropScale[0]:(center[0] + cropScale[0]), cropScale[1]:(center[1] + cropScale[1])]
    return cv2Object
def main():



    capture = cv2.VideoCapture(0)

    while True:
        if cv2.waitKey(1) & 0xFF == ord('q'):
            break

        ret, frame = capture.read()
        frame = Zoom(frame, 2)

        resize = cv2.resize(frame, (1500, 800));

        #cv2.imshow('Current',resize)

        gray = cv2.cvtColor(frame,cv2.COLOR_BGR2GRAY)
        image = Image.fromarray(gray)
        width, height = image.size
        zbar_image = zbar.Image(width, height, 'Y800', image.tobytes())
        scanner = zbar.ImageScanner()
        scanner.scan(zbar_image)

        for decoded in zbar_image:
            points=decoded.location
            print(decoded.data)
            if len(points) > 4:
                hull = cv2.convexHull(np.array([point for point in points], dtype=np.float32))
                hull = list(map(tuple, np.squeeze(hull)))
            else:
                hull = points;
            n = len(hull)
            for j in range(0, n):
                cv2.line(frame, hull[j], hull[(j + 1) % n], (255, 0, 0), 3)
        frame = cv2.resize(frame, (1500, 800));
        blank_image = np.zeros((height, width, 3), np.uint8)
        blank_image = cv2.resize(blank_image, (1500, 1000));
        cv2.imshow("Results", frame);

        for decoded in zbar_image:
            points=decoded.location
            ll=[point for point in points]
            # x1=min(1500-ll[0][0],ll[1][0],ll[2][0],ll[3][0])#top-left pt. is the leftmost of the 4 points
            # x2=max(1500-ll[0][0],ll[1][0],ll[2][0],ll[3][0])#bottom-right pt. is the rightmost of the 4 points
            # y1=min(1500-ll[0][1],ll[1][1],ll[2][1],ll[3][1])#top-left pt. is the uppermost of the 4 points
            # y2=max(1500-ll[0][1],ll[1][1],ll[2][1],ll[3][1])#bottom-right pt. is the lowermost of the 4 points
            #print("coordinates")
            #cv2.line(blank_image,(h1,h2),(1500-ll[0][0],ll[0][1]),(255,255,255),15)

            cv2.line(blank_image,(1500-ll[0][0],ll[0][1]),(1500-ll[1][0],ll[1][1]),(255,255,255),25)
            cv2.line(blank_image,(1500-ll[1][0],ll[1][1]),(1500-ll[2][0],ll[2][1]),(255,255,255),25)
            cv2.line(blank_image,(1500-ll[2][0],ll[2][1]),(1500-ll[3][0],ll[3][1]),(255,255,255),25)
            cv2.line(blank_image,(1500-ll[3][0],ll[3][1]),(1500-ll[0][0],ll[0][1]),(255,255,255),25)
            cv2.line(blank_image,(1500-ll[0][0],ll[0][1]),(1500-ll[2][0],ll[2][1]),(255,255,255),25)
            cv2.line(blank_image,(1500-ll[2][0],ll[2][1]),(1500-ll[2][0],ll[2][1]),(0,0,255),25)


        cv2.imshow("lol", blank_image);


if __name__ == "__main__":
    main()